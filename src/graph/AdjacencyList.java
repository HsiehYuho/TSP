package graph;

import java.util.Collections;
import java.util.LinkedList;
import java.util.Random;

/**
 * 
 * @author Courtney Wong
 * Georgia Institute of Technology, Fall 2018
 *
 * CSE6140 Project, Travel Salesman Problem
 * Adjacency list class for performing DFS in the Approx class
 */

public class AdjacencyList <E> {
	private final int n;
	private int m;
	private int cost;
	private LinkedList<Integer>[] list;
	
	public AdjacencyList(int n) {
		this.n = n;
		this.m = 0;
		this.cost = 0;
		this.list = new LinkedList[n];
		for (int ii = 0; ii < n; ii++) {
			this.list[ii] = new LinkedList<Integer>();
		}
	}
	
	/**
	 * Adds an edge at a random index in order to randomize DFS.
	 * @param a one end node
	 * @param b the other end node
	 * @param rand
	 * @param cost of the edge
	 */
	public void addEdge(int a, int b, Random rand, int cost) {
		
		if (this.getEdgeList(a).size() == 0) {
			this.list[a].add(b);
		} else {
			this.list[a].add(rand.nextInt(this.getEdgeList(a).size()), b);
		}
		
		if (this.getEdgeList(b).size() == 0) {
			this.list[b].add(a);
		} else {
			this.list[b].add(rand.nextInt(this.getEdgeList(b).size()), a);
		}
		
		this.m++;
		this.cost+=cost;
	}
	 /**
	  * Shuffles the order of each node's neighbor list for randomized DFS
	  * @param rand random stream generated by a seed
	  */
	public void shuffleNeighbors(Random rand) {
		for (int ii = 0; ii < this.numNodes(); ii++) {
			if (this.getEdgeList(ii).size() > 1) { // shuffle only if more than 1 neighbor
				Collections.shuffle(this.list[ii], rand);
			}
		}
	}
	
	/**
	 * Gets the number of nodes in this adjacency list
	 * @return n number of nodes
	 */
	public int numNodes() {
		return this.n;
	}
	
	/**
	 * Gets the number of unique edges in this adjacency list
	 * @return m number of edges
	 */
	public int numEdges() {
		return this.m;
	}
	
	/**
	 * Gets the total cost of the entire graph represented in this adjacency list
	 * @return cost
	 */
	public int getCost() {
		return this.cost;
	}
	
	/**
	 * Gets the linked edge list of a specified node
	 * @param n the input node
	 * @return the linked edge list of n
	 */
	public LinkedList<Integer> getEdgeList(int n) {
		return this.list[n];
	}
	
	/**
	 * Prints this adjacency list with one node per line in the format <node1> -> [<edge1>, <edge2>, <edge3>...]
	 */
	public void print() {
		for (int ii = 0; ii < n; ii++) {
			System.out.println(String.format("%d -> %s", ii, this.getEdgeList(ii).toString()));
		}
	}
	
	public boolean isConnected(int a, int b) {
		if (this.getEdgeList(a).contains(b)) {
			return true;
		} else {
			return false;
		}
	}
	
	public void addAll(AdjacencyList<Integer> template) {
		for (int ii = 0; ii < template.numNodes(); ii++) {
			this.list[ii].addAll(template.getEdgeList(ii));
		}
	}
}
